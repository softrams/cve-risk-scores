#!/usr/bin/env node

const fs = require("fs");
const zlib = require("node:zlib");
const { pipeline } = require("node:stream/promises");
const { Readable } = require("stream");
const { finished } = require("stream/promises");
const yargs = require("yargs");

const EPSS_DATA_FOLDER =
  process.env.EPSS_DATA_FOLDER || process.env.HOME || "/tmp";

const epssScores = {};
const kevData = {};

async function downloadFile(url, path) {
  const outfile = fs.createWriteStream(path);
  const response = await fetch(url);
  await finished(Readable.fromWeb(response.body).pipe(outfile));
}

async function syncKEV(refresh = false) {
  if (!fs.existsSync(`${EPSS_DATA_FOLDER}/.epss`)) {
    console.log(`\nCreating ${EPSS_DATA_FOLDER}/.epss folder`);
    fs.mkdirSync(`${EPSS_DATA_FOLDER}/.epss`);
  }

  if (!fs.existsSync(`${EPSS_DATA_FOLDER}/.epss/kev.json`) || refresh) {
    console.log(`\nDownloading CISA Known Exploited Vulnerabilities catalog`);
    await downloadFile(
      "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json",
      `${EPSS_DATA_FOLDER}/.epss/kev.json`
    );
  }
}

async function syncEpss(refresh = false) {
  if (!fs.existsSync(`${EPSS_DATA_FOLDER}/.epss`)) {
    console.log(`\nCreating ${EPSS_DATA_FOLDER}/.epss folder`);
    fs.mkdirSync(`${EPSS_DATA_FOLDER}/.epss`);
  }

  if (!fs.existsSync(`${EPSS_DATA_FOLDER}/.epss/epss.csv.gz`) || refresh) {
    console.log(`\nDownloading EPSS scores`);
    await downloadFile(
      "https://epss.cyentia.com/epss_scores-current.csv.gz",
      `${EPSS_DATA_FOLDER}/.epss/epss.csv.gz`
    );
  }

  if (!fs.existsSync(`${EPSS_DATA_FOLDER}/.epss/epss.csv`) || refresh) {
    // Download GZ file and unzip it
    console.log("\nUnzipping EPSS scores data file");
    const input = fs.createReadStream(`${EPSS_DATA_FOLDER}/.epss/epss.csv.gz`);
    const output = fs.createWriteStream(`${EPSS_DATA_FOLDER}/.epss/epss.csv`);
    const unzip = zlib.createGunzip();
    await pipeline(input, unzip, output);
  }
}

async function loadKEVCatalog(refresh = false) {
  const kevContents = fs.readFileSync(
    `${EPSS_DATA_FOLDER}/.epss/kev.json`,
    "utf8"
  );
  const kev = JSON.parse(kevContents);
  for (const item of kev.vulnerabilities) {
    kevData[item.cveID] = {
      ...item,
    };
  }
}

async function loadScores(refresh = false) {
  const csv = fs.readFileSync(`${EPSS_DATA_FOLDER}/.epss/epss.csv`, "utf8");
  const lines = csv.split("\n");
  let idx = 1;
  for (const line of lines) {
    // skip headers
    if (refresh && idx == 1) {
      console.log(`\nEPSS Scores refreshed at ${new Date().toLocaleString()} `);
      console.log(`${line}\n`);
    }

    if (idx > 2) {
      const [cve, epss, percentile] = line.split(",");
      epssScores[cve] = {
        epss,
        percentile,
      };
    }
    idx++;
  }
  // console.log(`Loaded  ${idx} EPSS scores`);
}

// Check CVSS Score in NVD database for the CVE
async function checkCVSS(cveID) {
  const response = await fetch(
    `https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cveID}`
  );
  const data = await response.json();
  if (data.totalResults == 0) {
    return;
  }

  const cvssScoreV31 = data.vulnerabilities[0].cve.metrics.cvssMetricV31;
  return cvssScoreV31 ? cvssScoreV31[0] : null;
}

async function audit(
  cveID,
  verbose = false,
  threshold = 0.0,
  failOnPastDue = false,
  score = 0.0
) {
  let tabularData = [];

  const cveRegex = new RegExp(`^CVE-\\d{4}-\\d{4,}$`);
  if (!cveRegex.test(cveID)) {
    console.warn(
      `\n Invalid CVE number ${cveID}. Expecting number as: CVE-YYYY-XXXX.\n`
    );
    process.exit(1);
  }

  const today = new Date();

  console.log(`\n Auditing ${cveID} at ${new Date().toLocaleString()} \n`);

  if (!epssScores[cveID]) {
    console.log(` No EPSS score found for CVE ${cveID}\n`);
  } else {
    const { epss, percentile } = epssScores[cveID];
    console.log(
      `\n EPSS score (probability of exploitation) : ${+Number(
        epss * 100.0
      ).toFixed(3)}% \n`
    );

    // If EPSS score is above threshold, fail the audit
    if (Number(threshold) > 0.0 && parseFloat(epss) > threshold) {
      console.warn(
        ` EPSS score is above threshold of ${threshold}. Failing the audit.\n`
      );
      process.exit(2);
    }
  }

  if (!kevData[cveID]) {
    console.log(` No CISA KEV data found for CVE ${cveID}\n`);
  } else {
    const { dateAdded, dueDate } = kevData[cveID];
    console.log(` CISA KEV Date Added: ${dateAdded}, Due Date: ${dueDate}\n`);

    // If CVE is past due date, fail the audit
    if (failOnPastDue && new Date(dueDate) < today) {
      console.warn(
        `\n CVE is past due date of ${dueDate}. Failing the audit.\n`
      );
      process.exit(2);
    }
  }

  const cvssScoreV31 = await checkCVSS(cveID);
  if (!cvssScoreV31) {
    console.log(` No CVSS score found for CVE ${cveID}\n`);
  } else {
    const { exploitabilityScore, impactScore } = cvssScoreV31;
    const { baseScore, baseSeverity } = cvssScoreV31.cvssData;
    console.log(` CVSS v3.1 Base Score: ${baseScore} (${baseSeverity}) 
                \n\t Exploitability Score: ${exploitabilityScore} Impact Score : ${impactScore} \n`);

    // If CVSS score is above threshold, fail the audiat
    if (Number(score) > 0.0 && parseFloat(baseScore) > score) {
      console.warn(
        ` CVSS v3.1 Base Score is above threshold of ${score}. Failing the audit.\n`
      );
      process.exit(2);
    }
  }

  process.exit(0);
}

(async () => {
  try {
    const options = yargs
      .scriptName("cve-risk-scores")
      .usage(
        "Usage: $0 <CVE-NUMBER> [-v|--verbose] [-r|--refresh] [-f|--fail-on-past-duedate] [-t|--threshold] [-s|--score] "
      )
      .option("v", {
        alias: "verbose",
        describe: "Verbose output",
      })
      .option("r", { alias: "refresh", describe: "Refresh EPSS, KEV data" })
      .option("f", {
        alias: "fail-on-past-duedate",
        describe: "Fail on past CISA KVE due date",
      })
      .option("t", {
        alias: "threshold",
        describe: "EPSS score threshold to fail the audit",
        type: "number",
        default: 0.0,
      })
      .option("s", {
        alias: "score",
        describe: "CVSS score threshold to fail the audit",
        type: "number",
        default: 0.0,
      })
      .help(true).argv;

    // If no CVE number is provided, print help
    if (options._.length == 0) {
      yargs.showHelp();
      process.exit(0);
    }

    await syncEpss(options.refresh);
    await syncKEV(options.refresh);

    await loadScores(options.refresh);
    await loadKEVCatalog(options.refresh);

    await audit(
      options._[0],
      options.verbose,
      options.threshold,
      options["fail-on-past-duedate"],
      options.score
    );
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
})();
