#!/usr/bin/env node

const fs = require("fs");
const zlib = require("node:zlib");
const { pipeline } = require("node:stream/promises");
const { Readable } = require("stream");
const { finished } = require("stream/promises");
const yargs = require("yargs");

const EPSS_DATA_FOLDER =
  process.env.EPSS_DATA_FOLDER || process.env.HOME || "/tmp";

const epssScores = {};
const kevData = {};

async function downloadFile(url, path) {
  const outfile = fs.createWriteStream(path);
  const response = await fetch(url);
  await finished(Readable.fromWeb(response.body).pipe(outfile));
}

async function syncKEV(refresh = false) {
  if (!fs.existsSync(`${EPSS_DATA_FOLDER}/.epss`)) {
    console.log(`\nCreating ${EPSS_DATA_FOLDER}/.epss folder`);
    fs.mkdirSync(`${EPSS_DATA_FOLDER}/.epss`);
  }

  if (!fs.existsSync(`${EPSS_DATA_FOLDER}/.epss/kev.json`) || refresh) {
    console.log(`\nDownloading CISA Known Exploited Vulnerabilities catalog`);
    await downloadFile(
      "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json",
      `${EPSS_DATA_FOLDER}/.epss/kev.json`
    );
  }
}

async function syncEpss(refresh = false) {
  if (!fs.existsSync(`${EPSS_DATA_FOLDER}/.epss`)) {
    console.log(`\nCreating ${EPSS_DATA_FOLDER}/.epss folder`);
    fs.mkdirSync(`${EPSS_DATA_FOLDER}/.epss`);
  }

  if (!fs.existsSync(`${EPSS_DATA_FOLDER}/.epss/epss.csv.gz`) || refresh) {
    console.log(`\nDownloading EPSS scores`);
    await downloadFile(
      "https://epss.cyentia.com/epss_scores-current.csv.gz",
      `${EPSS_DATA_FOLDER}/.epss/epss.csv.gz`
    );
  }

  if (!fs.existsSync(`${EPSS_DATA_FOLDER}/.epss/epss.csv`) || refresh) {
    // Download GZ file and unzip it
    console.log("\nUnzipping EPSS scores data file");
    const input = fs.createReadStream(`${EPSS_DATA_FOLDER}/.epss/epss.csv.gz`);
    const output = fs.createWriteStream(`${EPSS_DATA_FOLDER}/.epss/epss.csv`);
    const unzip = zlib.createGunzip();
    await pipeline(input, unzip, output);
  }
}

async function loadKEVCatalog(refresh = false) {
  const kevContents = fs.readFileSync(
    `${EPSS_DATA_FOLDER}/.epss/kev.json`,
    "utf8"
  );
  const kev = JSON.parse(kevContents);
  for (const item of kev.vulnerabilities) {
    kevData[item.cveID] = {
      ...item,
    };
  }
}

async function loadScores(refresh = false) {
  const csv = fs.readFileSync(`${EPSS_DATA_FOLDER}/.epss/epss.csv`, "utf8");
  const lines = csv.split("\n");
  let idx = 1;
  for (const line of lines) {
    // skip headers
    if (refresh && idx == 1) {
      console.log(`\nEPSS Scores refreshed at ${new Date().toLocaleString()} `);
      console.log(`${line}\n`);
    }

    if (idx > 2) {
      const [cve, epss, percentile] = line.split(",");
      epssScores[cve] = {
        epss,
        percentile,
      };
    }
    idx++;
  }
  // console.log(`Loaded  ${idx} EPSS scores`);
}

// Check CVSS Score in NVD database for the CVE
async function checkCVSS(cveID) {
  try {
    const response = await fetch(
      `https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cveID}`
    );

    const data = await response.json();
    if (data.totalResults == 0) {
      return;
    }

    const cvssScoreV31 = data.vulnerabilities[0].cve.metrics.cvssMetricV31;
    return cvssScoreV31 ? cvssScoreV31[0] : null;
  } catch (err) {
    console.log(`Error fetching CVSS score for ${cveID}`);
    console.error(err);
    return null;
  }
}

async function audit(
  cveIDStr,
  verbose = false,
  threshold = 0.0,
  failOnPastDue = false,
  score = 0.0,
  delay = 0.0
) {
  let tabularData = [];
  let cveIDs = [];
  let counter = 0;

  let cveAuditFail = false;
  let epssAuditFail = false;
  let kevAuditFail = false;

  // If multiple CVEs are provided, audit each one
  if (cveIDStr.includes(",")) {
    cveIDs = cveIDStr.split(",").map((cve) => cve.trim());
  } else {
    cveIDs.push(cveIDStr.trim());
  }

  for (const cveID of cveIDs) {
    const cveRegex = new RegExp(`^CVE-\\d{4}-\\d{4,}$`);

    let epssScore = null;
    let kevDueDate = null;
    let cvssScore = null;

    if (!cveRegex.test(cveID)) {
      console.warn(
        `\n Invalid CVE number ${cveID}. Expecting number as: CVE-YYYY-XXXX. Skipping.\n`
      );
      // continue the loop
      continue;
    }

    const today = new Date();

    counter++;

    console.log(
      `\n Auditing ${counter} of ${
        cveIDs.length
      } ${cveID} at ${new Date().toLocaleString()} \n`
    );

    if (!epssScores[cveID]) {
      console.log(` No EPSS score found for CVE ${cveID}\n`);
    } else {
      const { epss, percentile } = epssScores[cveID];

      epssScore = +Number(epss * 100.0).toFixed(3);

      console.log(
        `\n EPSS score (probability of exploitation) : ${+Number(
          epss * 100.0
        ).toFixed(3)}% \n`
      );

      // If EPSS score is above threshold, fail the audit
      if (Number(threshold) > 0.0 && parseFloat(epss) > threshold) {
        console.warn(
          ` EPSS score is above threshold of ${threshold}. Failing the audit.\n`
        );
        epssAuditFail = true;
      }
    }

    if (!kevData[cveID]) {
      console.log(` No CISA KEV data found for CVE ${cveID}\n`);
    } else {
      const { dateAdded, dueDate } = kevData[cveID];
      kevDueDate = dueDate;

      console.log(` CISA KEV Date Added: ${dateAdded}, Due Date: ${dueDate}\n`);

      // If CVE is past due date, fail the audit
      if (failOnPastDue && new Date(dueDate) < today) {
        console.warn(
          `\n CVE is past due date of ${dueDate}. Failing the audit.\n`
        );
        kevAuditFail = true;
      }
    }

    const cvssScoreV31 = await checkCVSS(cveID);
    if (!cvssScoreV31) {
      console.log(` No CVSS score found for CVE ${cveID}\n`);
    } else {
      const { exploitabilityScore, impactScore } = cvssScoreV31;
      const { baseScore, baseSeverity } = cvssScoreV31.cvssData;
      console.log(` CVSS v3.1 Base Score: ${baseScore} (${baseSeverity}) 
                \n\t Exploitability Score: ${exploitabilityScore} Impact Score : ${impactScore} \n`);

      cvssScore = baseScore;

      // If CVSS score is above threshold, fail the audiat
      if (Number(score) > 0.0 && parseFloat(baseScore) > score) {
        console.warn(
          ` CVSS v3.1 Base Score is above threshold of ${score}. Failing the audit.\n`
        );
        cveAuditFail = true;
      }
    }

    tabularData.push({
      "CVE ID": cveID,
      "EPSS Score (%)": epssScore ? epssScore : "N/A",
      "CVSS Base Score": cvssScore ? cvssScore : "N/A",
      "CISA KEV Due Date": kevDueDate ? kevDueDate : "N/A",
    });

    // print a line separator
    console.log("-".repeat(40));

    // Try adding a delay to avoid rate limiting
    if (Number(delay) > 0.0 && cveIDs.length > 2 && counter < cveIDs.length) {
      await new Promise((resolve) => setTimeout(resolve, Number(delay) * 1000));
    }
  }

  if (tabularData.length > 0) {
    console.log("\n Audit Summary \n");
    console.table(tabularData);
  }

  if (cveAuditFail || epssAuditFail || kevAuditFail) {
    console.warn(
      `\n Audit failed. Please review the CVEs above and take appropriate action.\n`
    );
    process.exit(2);
  }

  process.exit(0);
}

(async () => {
  try {
    const options = yargs
      .scriptName("cve-risk-scores")
      .usage(
        "Usage: $0 <CVE-NUMBER> [-v|--verbose] [-r|--refresh] [-f|--fail-on-past-duedate] [-t|--threshold] [-s|--score] "
      )
      .option("v", {
        alias: "verbose",
        describe: "Verbose output",
      })
      .option("r", { alias: "refresh", describe: "Refresh EPSS, KEV data" })
      .option("f", {
        alias: "fail-on-past-duedate",
        describe: "Fail on past CISA KVE due date",
      })
      .option("t", {
        alias: "threshold",
        describe: "EPSS score threshold to fail the audit",
        type: "number",
        default: 0.0,
      })
      .option("s", {
        alias: "score",
        describe: "CVSS score threshold to fail the audit",
        type: "number",
        default: 0.0,
      })
      .option("d", {
        alias: "delay",
        describe: "Delay between each CVE audit, in seconds",
        type: "number",
        default: 0.0,
      })
      .help(true).argv;

    // If no CVE number is provided, print help
    if (options._.length == 0) {
      yargs.showHelp();
      process.exit(0);
    }

    await syncEpss(options.refresh);
    await syncKEV(options.refresh);

    await loadScores(options.refresh);
    await loadKEVCatalog(options.refresh);

    await audit(
      options._[0],
      options.verbose,
      options.threshold,
      options["fail-on-past-duedate"],
      options.score,
      options["delay"]
    );
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
})();
